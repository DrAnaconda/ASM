using System;
using System.Linq;
using System.Threading.Tasks;
using ASM.Models.ScreenMeterModels;
using ASM.Models.ScreenMeterRequests;
using ASM.Models.ScreenMeterResponses;
using ASM.ScreenMeterFaker.Abstractions;
using ASM.ScreenMeterFaker.Configuration;
using Microsoft.Extensions.Options;
using RestSharp;
using Tools.Configuration.Parser;
using Tools.Library.HttpClient.Abstractions;
using Tools.Library.HttpClient.Implementations;
using Parameter = Tools.Library.HttpClient.CustomClasses.Parameter;

namespace ASM.ScreenMeterFaker.Implementation
{
    // TODO: Get server time and use server time instead of autogenerated

    public class IsmFaker : ISM
    {
        private UserModel currentUser { get; set; } = null;
        private SMLoginResponse SmServerSettings { get; set; } = null;
        private LogData previousLogData { get; set; } = null;

        private readonly SMConfiguration _smConfiguration;

        private readonly ICustomHttpWrapper _customHttpWrapper;

        public IsmFaker(IOptions<SMConfiguration> configuration)
        {
            if (configuration == null) throw new ArgumentNullException(nameof(configuration));
            _smConfiguration = configuration.Value; 
            configureService();
            _customHttpWrapper = new RestClientWrapper(_smConfiguration.baseUrl);
        }

        private void configureService()
        {
            if (_smConfiguration.readFromEnv)
            {
                EnvironmentConfigurationParser.AutoParseProperties(_smConfiguration, false);
            }
        }

        public async Task<SMLoginResponse> AuthorizeAsync()
        {
            if (this.SmServerSettings == null)
            {
                var screenMeterAuthorizeBody = new SMLoginRequest(
                    this._smConfiguration.username,
                    this._smConfiguration.password);

                this.SmServerSettings = await _customHttpWrapper.MakeJsonPostRequestAsync
                    <SMLoginResponse, SMLoginRequest>(screenMeterAuthorizeBody, "login");
            }

            return this.SmServerSettings;
        }

        public Task<SMLoginResponse> AuthorizeAsync(string userId, string password)
        {
            this._smConfiguration.username = userId;
            this._smConfiguration.password = password;
            return AuthorizeAsync();
        }

        public int GetScreenshotSyncPeriodInMinutes()
        {
            return this.SmServerSettings.screenshotInterval;
        }

        public async Task SendScreenshotReportAsync(byte[] screenshotBytes)
        {
            var request = buildLogRequest(true);
            var linksForUpload = await this.retrieveLinksForUploadingOrJustSync(request);
            var fullDefinitionTask = _customHttpWrapper.MakeJsonPutRequestAsync(screenshotBytes, linksForUpload.signedUrl);
            var thumbnailTask = _customHttpWrapper.MakeJsonPutRequestAsync(screenshotBytes, linksForUpload.signedUrlthumb);
            await Task.WhenAll(fullDefinitionTask, thumbnailTask);
        }

        public Task SendReportAsync()
        {
            var request = buildLogRequest(false);
            return retrieveLinksForUploadingOrJustSync(request);
        }

        public async Task<UserModel> RetrieveUserData()
        {
            var url = $"{_smConfiguration.baseUrlUi}/TimeSheet/UserIndex";
            var result = await _customHttpWrapper.MakeGetRequestAsync<object>(url, ArraySegment<Parameter>.Empty);
            
            throw new NotImplementedException();
        }

        public async Task<TimeSheetPage> RetrieveTimeSheetAsync(SMTimesheetRequest timesheetRequest)
        {
            var httpParams = new Parameter[]
            {
                new(ParameterType.QueryString, nameof(SMTimesheetRequest.year), timesheetRequest.year.ToString()),
                new(ParameterType.QueryString, nameof(SMTimesheetRequest.day), timesheetRequest.day),
                new(ParameterType.QueryString, nameof(SMTimesheetRequest.month), timesheetRequest.month),
                new Parameter(ParameterType.QueryString, nameof(SMTimesheetRequest.diff), timesheetRequest.diff.ToString())
            };
            var requestUrl = $"{_smConfiguration.baseUrlUi}/TimeSheet/UserIndex/{this.SmServerSettings.guid}";
            var response = await _customHttpWrapper.MakeGetRequestAsync<object>(requestUrl, httpParams);

            throw new NotImplementedException();
        }

        public Task PublishManualLogAsync(SMManualLogCreateRequest request)
        {
            throw new NotImplementedException();
        }

        #region Logger builder
        
        private SMLogRequest buildLogRequest(bool isScreenshot)
        {
            lock (this)
            {
                var logData = buildLogData(isScreenshot);
                var request = new SMLogRequest(
                    logData,
                    this._smConfiguration.username,
                    this._smConfiguration.password);
                return request;
            }
        }

        private LogData buildLogData(bool isScreenshot)
        {
            if (this.previousLogData == null)
            {
                var currentTask = this.SmServerSettings.activeProject.openTasks.First();
                this.previousLogData = new LogData(currentTask.taskId, 0, 0, true, true);
            }
            else
            {
                this.previousLogData.regenerateLogData(isScreenshot);
                //randomizer.Next(this._smConfiguration.mouseClicksPerMinute),
                //randomizer.Next(this._smConfiguration.keyboardClicksPerMinute),
                //isScreenshot);
            }

            return this.previousLogData;
        }

        private Task<SMLogResponse> retrieveLinksForUploadingOrJustSync(SMLogRequest request)
        {
            return _customHttpWrapper.MakeJsonPostRequestAsync
                <SMLogResponse, SMLogRequest>(request, "syncData");
        }

        #endregion
    }
}